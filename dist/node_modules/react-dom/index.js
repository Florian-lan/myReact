(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.index = global.index || {}, global.index.js = factory()));
})(this, (function () { 'use strict';

    // 记录FiberNode的tag属性，记录fiber节点的类型，如是不是根节点，是不是函数fiber等
    const FunctionComponent = 0;
    const HostRoot = 3; // 就是如React.render()挂载的根节点 hostRootFiber类型
    const HostComponent = 5; // 如 div
    const HostText = 6; // 如<div> 123</div> 中的123

    const NoFlags = 0b0000001;
    const Placement = 0b0000010;
    const Update = 0b0000100;
    const childDeletion = 0b0001000;
    const MutationMask = Placement | Update | childDeletion;

    // 为什么要在tsconfig.json中配置，因为hostConfig不仅仅在reconciler包中需要，其他包也需要
    class FiberNode {
        type;
        tag;
        pendingProps;
        key;
        stateNode;
        return;
        sibling;
        child;
        index;
        ref;
        memoizedProps;
        memoizedState;
        alternate;
        flags;
        subtreeFlags;
        updateQueue;
        // pendingProps 就是当前Fiber节点将要变化的Props属性（新的Props属性)
        constructor(tag, pendingProps, key) {
            // 实例属性
            this.tag = tag; // 比如FunctionComponent, HostComponent
            this.key = key;
            this.stateNode = null; // 对于一个为div的HostComponent节点来说，stateNode保存了div这个dom节点
            this.type = null; // 如对于一个FunctionComponent（tag）来说，type是function本身;对于div节点来说，type就是“div”
            // 构成树状结构的属性：用于表示节点之间的关系的属性
            this.return = null; //记录父节点
            this.sibling = null;
            this.child = null;
            this.index = 0; // 同级的fiberNode有多个时，用index记录索引
            this.ref = null;
            // 作为工作单元
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.memoizedState = null;
            this.alternate = null;
            this.flags = NoFlags; // flags：副作用，标记Fiber要执行的状态，如删除delete，palcement等
            this.subtreeFlags = NoFlags;
            this.updateQueue = null;
        }
    }
    class FiberRootNode {
        container; //保存fiber在宿主环境中挂载的节点信息，如在dom宿主环境中就是dom节点（root）
        current;
        finishedWork;
        constructor(container, hostRootFiber) {
            this.container = container;
            this.current = hostRootFiber;
            hostRootFiber.stateNode = this;
            this.finishedWork = null;
        }
    }
    // 传入current节点，返回对应的workInProgress节点
    // 双缓存机制
    const createWorkInProgress = (current, pendingProps) => {
        let workInProgress = current.alternate;
        if (workInProgress === null) {
            // 首屏渲染时：mount
            workInProgress = new FiberNode(current.tag, pendingProps, current.key);
            workInProgress.stateNode = current.stateNode;
            workInProgress.alternate = current;
            current.alternate = workInProgress;
        }
        else {
            // 对应update
            workInProgress.pendingProps = pendingProps;
            workInProgress.flags = NoFlags;
            workInProgress.subtreeFlags = NoFlags;
        }
        workInProgress.type = current.type;
        workInProgress.updateQueue = current.updateQueue;
        workInProgress.child = current.child;
        workInProgress.memoizedProps = current.memoizedProps;
        workInProgress.memoizedState = current.memoizedState;
        return workInProgress;
    };
    function createFiberFromElement(element) {
        const { type, key, props } = element;
        let fiberTag = FunctionComponent; // 设置默认为函数组件
        if (typeof type === 'string') {
            // <div> 的type: 'div'
            fiberTag = HostComponent;
        }
        else if (typeof type !== 'function' && true) {
            // 因为设置的默认是函数组件，所以这里判断是不是'function'
            // 考虑到边界情况
            console.warn("未定义的type类型", element);
        }
        const fiber = new FiberNode(fiberTag, props, key);
        fiber.type = type;
        return fiber;
    }

    const createUpdate = (action) => {
        return {
            action
        };
    };
    // 注意在UpdateQueue中为什么pending的update是存放在shared中的，
    // 这样的话，在current和workInProgress的updateQueue属性，指向的就都是同一个shared(公用updateQueue)
    const createUpdateQueue = () => {
        return {
            shared: {
                pending: null
            }
        };
    };
    const enqueueUpdate = (updateQueue, update) => {
        updateQueue.shared.pending = update;
    };
    const processUpdateQueue = (baseState, pendingUpdate) => {
        const result = {
            memoizedState: baseState
        };
        if (pendingUpdate !== null) {
            const action = pendingUpdate.action;
            if (action instanceof Function) {
                // baseState 1 update(x)=> 4x  => memoizedState 4
                result.memoizedState = action(baseState);
            }
            else {
                // baseState 1 update 2 => memoizedState 2
                result.memoizedState = action;
            }
        }
        return result;
    };

    // Symbol的作用：创建一个独一无二的属性名，避免命名冲突
    // 通过判断Symbol的类型和Symbol是否存在 判断当前宿主环境是否支持Symbol
    const supportSymbol = typeof Symbol === 'function' && Symbol.for;
    // 该常量用于唯一标识这是一个React组件，赋值给$$typeof
    const REACT_ELEMENT_TYPE = supportSymbol ? Symbol.for('react.element') : 0xeac7;
    // 如果symbol不支持，设置为自定义的一个数字(React源码使用的就是0xeac7)

    //shouldTrackEffects用于判断是否需要确认副作用
    function ChildReconciler(shoudlTrackEffects) {
        function reconcileSingleElement(returnFiber, currentFiber, element) {
            // 根据Element创建FiberNode并返回
            const fiber = createFiberFromElement(element);
            fiber.return = returnFiber;
            return fiber;
        }
        function reconcileSingleTextNode(returnFiber, currentFiber, content) {
            const fiber = new FiberNode(HostText, { content }, null);
            fiber.return = returnFiber;
            return fiber;
        }
        // 传进来的fiber就是刚创建的fiber，肯定是workInProgress的fiber
        function placeSingleChild(fiber) {
            // 在应该追踪副作用+首屏渲染的情况下，才加入标记Placement
            if (shoudlTrackEffects && fiber.alternate === null) {
                fiber.flags |= Placement;
            }
            return fiber;
        }
        // 根据不同的shoudlTrackEffects返回不同的处理函数(beginWork函数中处理不同case会调用的函数)
        return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
            // 判断的那个前fiber的类型
            if (typeof newChild === 'object' && newChild !== null) {
                switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                        return placeSingleChild(
                        // 把新创建的fiber传给placeSingleChild
                        reconcileSingleElement(returnFiber, currentFiber, newChild));
                    default:
                        {
                            console.warn("未实现的reconcile类型", newChild);
                        }
                        break;
                }
            }
            // 多节点的情况 TODO
            //  HostText
            if (typeof newChild === 'string' || typeof newChild === 'number') {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
            }
            {
                console.warn("未实现的reconcil类型", newChild);
            }
            // return FiberNode
            return null;
        };
    }
    const reconcileChildFibers = ChildReconciler(true);
    const mountChildFibers = ChildReconciler(false);

    // 深度优先递归中的“递”阶段
    const beginWork = (workInProgress) => {
        // 比较current和workInProgress，然后返回子节点进行递归
        switch (workInProgress.tag) {
            // 进行处理，然后返回workInProgress的子节点继续往下遍历
            // 处理方式：根据dom节点完成“创建、复用和更新Fiber对象”
            case HostRoot:
                return updateHostRoot(workInProgress);
            case HostComponent:
                return updateHostComponent(workInProgress); // 
            case HostText:
                // 就是更新到了叶子节点，比如<div>123</div> 这个123是没有对应的FiberNode的
                return null;
            default:
                {
                    console.warn('beginWork未实现的类型');
                }
                break;
        }
        return null;
    };
    function updateHostRoot(workInProgress) {
        const baseState = workInProgress.memoizedProps;
        const updateQueue = workInProgress.updateQueue;
        const pending = updateQueue.shared.pending; // 将pending的所有update拿出来计算
        updateQueue.shared.pending = null; // 拿出来计算之后，这些update就不需要了
        // 基于baseState和update进行计算新的State
        const { memoizedState } = processUpdateQueue(baseState, pending);
        workInProgress.memoizedState = memoizedState; // 计算完之后进行复制
        // 其实对于HostRoot来说，这里的memoizedState就是<App/>对应的FIberNode这个
        const nextChildren = workInProgress.memoizedState;
        reconcileChildren(workInProgress, nextChildren); // 该方法返回子FiberNode
        return workInProgress.child;
    }
    function updateHostComponent(workInProgress) {
        const nextProps = workInProgress.pendingProps;
        const nextChildren = nextProps.children;
        reconcileChildren(workInProgress, nextChildren); // TODO 这个函数是干啥的：根据reactElement生成fiber节点，并拼在fiber树上
        return workInProgress.child;
    }
    function reconcileChildren(workInProgress, children) {
        const current = workInProgress.alternate;
        if (current !== null) {
            // 对于HostRootFiber节点总会进入当前阶段
            // update phase
            workInProgress.child = reconcileChildFibers(workInProgress, current?.child, children);
        }
        else {
            // mount phase
            workInProgress.child = mountChildFibers(workInProgress, null, children);
        }
        // 第二三个参数是比较双方，比较当前节点的child，以及这个child对应的ReactElement
    }

    // TODO 这一这里type的来源，type可以创建react-dom类型
    const createInstance = (type, props) => {
        // TODO 处理props
        const element = document.createElement(type);
        return element;
    };
    const appendInitialChild = (parent, child) => {
        parent.appendChild(child);
    };
    const createTextInstance = (content) => {
        return document.createTextNode(content);
    };
    const appendChildToContainer = appendInitialChild;

    let nextEffect = null;
    const commitMutationEffects = (finishedWork) => {
        nextEffect = finishedWork;
        while (nextEffect !== null) {
            // 向下遍历
            const child = nextEffect.child;
            if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags && child !== null) {
                // 向子节点遍历 直到找到第一个自身flags需要mutation的fiber
                nextEffect = child;
            }
            else {
                // 此时找到最底下的那个需要mutation的fiber节点
                // 向上回溯
                up: while (nextEffect !== null) {
                    commitMutationEffectsOnFiber(nextEffect);
                    const sibling = nextEffect.sibling;
                    if (sibling !== null) {
                        nextEffect = sibling;
                        break up;
                    }
                    nextEffect = nextEffect.return;
                }
            }
        }
    };
    const commitMutationEffectsOnFiber = (finishedWork) => {
        const flags = finishedWork.flags;
        // Placement
        if ((flags & Placement) !== NoFlags) {
            commitPlacement(finishedWork);
            finishedWork.flags &= ~Placement; // 移除Placement
        }
        // flags Update
        // flags ChildDeletion
    };
    const commitPlacement = (finishedWork) => {
        // 1. 插入到parent DOM
        {
            console.warn('commit阶段的commitPlacement', finishedWork);
        }
        // 获取parent DOM
        const hostParent = getHostParent(finishedWork);
        // 2. 根据finishedWork这个fiber找到对应的DOM节点
        appendPlacementNodeIntoContainer(finishedWork, hostParent);
    };
    function getHostParent(fiber) {
        let parent = fiber.return;
        while (parent) {
            const parentTag = parent.tag;
            //两种情况说明是宿主节点 HostComponent HostRoot   
            if (parentTag === HostComponent) {
                return parent.stateNode;
            }
            if (parentTag === HostRoot) { // 参考HostRoot结构
                return parent.stateNode.container;
            }
            parent = parent.return; // 往上找直到找到Host节点
        }
        {
            console.warn('未找到HostRoot');
        }
        return null;
    }
    // 此函数用于将传入的finishedWork节点对应的dom插入到hostParent中
    function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
        // 当前的finishedWork对应的不一定是host(dom)节点，所以是一个递归的过程
        //（对于插入的节点肯定不可能是HostRoot）
        if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
            appendChildToContainer(hostParent, finishedWork.stateNode);
            return;
        }
        // 如果当前finishedWork对应的不是host节点，对孩子递归操作（包括sibling）
        // 递归调用本函数，找到对应的 dom 然后插入
        const child = finishedWork.child;
        if (child !== null) {
            appendPlacementNodeIntoContainer(child, hostParent);
            let sibling = child.sibling;
            while (sibling !== null) {
                appendPlacementNodeIntoContainer(sibling, hostParent);
                sibling = sibling.sibling;
            }
        }
    }

    // 深度优先递归中的“归”： 构建离屏的DOM树 + 将flag冒泡到上级  TODO为啥
    // 因为completeWork是向上回溯的过程，所以此时遍历到的每一个节点都是当前最靠上的一个节点
    // 基于此，理解completWork的插入操作和 flags 的 bubble操作
    const completeWork = (workInProgress) => {
        const newProps = workInProgress.pendingProps;
        const current = workInProgress.alternate;
        switch (workInProgress.tag) {
            case HostComponent:
                if (current !== null && workInProgress.stateNode) ;
                else {
                    // mount阶段（首屏渲染）
                    // 1. 构建dom （在宿主包中完）
                    const instance = createInstance(workInProgress.type);
                    // 2. 将dom插入到dom树中: 将剩下的workInProgress中的dom挂载到新创建的instance下
                    appendAllChild(instance, workInProgress);
                    workInProgress.stateNode = instance;
                }
                bubbleProperties(workInProgress);
                return null;
            case HostText:
                if (current !== null && workInProgress.stateNode) ;
                else {
                    // mount阶段（首屏渲染）
                    // 1. 构建dom （在宿主包中完成）
                    const instance = createTextInstance(newProps.content);
                    // 2. 将dom插入到dom树中:  因为对于HostText是没有Child，不需要执行以下方法；
                    // appendAllChild(instance, workInProgress);
                    workInProgress.stateNode = instance;
                }
                bubbleProperties(workInProgress);
                return null;
            case HostRoot:
                bubbleProperties(workInProgress);
                return null;
            default:
                {
                    console.warn("未处理的complete边界情况", workInProgress);
                }
                break;
        }
    };
    // 如workInprogress Fiber是一个函数 function A(){return <div></div>}
    // 我们要插入的是A的子节点的div这个dom元素
    function appendAllChild(parent, workInProgress) {
        let node = workInProgress.child;
        while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
                // 插入
                appendInitialChild(parent, node?.stateNode);
            }
            else if (node.child !== null) { // 有孩子继续往下
                node.child.return = node;
                node = node.child;
                continue;
            }
            // 在递归的过程中，最终会往上归，归到头就结束
            if (node === workInProgress) {
                return;
            }
            // 往下没找到，找兄弟也没找到 -> 该往上归了
            if (node.sibling === null) {
                if (node.return === null || node.return === workInProgress) {
                    return;
                }
                node = node?.return; // 往上归
            }
            else {
                node.sibling.return = node.return;
                node = node.sibling;
            }
        }
    }
    function bubbleProperties(workInProgress) {
        let subtreeFlags = NoFlags;
        let child = workInProgress.child;
        // 将孩子（兄弟姐妹的）的副作用都冒泡到当前节点来
        while (child !== null) {
            subtreeFlags |= child.subtreeFlags;
            subtreeFlags |= child.flags;
            child.return = workInProgress;
            child = child.sibling;
        }
        workInProgress.subtreeFlags |= subtreeFlags;
    }

    let workInProgress = null;
    function scheduleUpdateOnFiber(fiber) {
        // TODO 调度功能
        const root = markUpdateFromFiberToRoot(fiber);
        renderRoot(root);
    }
    function markUpdateFromFiberToRoot(fiber) {
        let node = fiber;
        let parent = node.return;
        while (parent !== null) {
            node = parent;
            parent = node.return;
        }
        // 跳出循环了，说明找到了根节点
        if (node.tag === HostRoot) {
            return node.stateNode; // hostRootFiber.stateNode 保存的是FiberRootNode，
        }
        return null;
    }
    // 这里传入的fiber其实是hostRootFiber
    function prepareFreshStack(root) {
        workInProgress = createWorkInProgress(root.current, {});
    }
    function renderRoot(root) {
        // 初始化，如初始化workInProgress指针
        prepareFreshStack(root);
        const temp = true;
        // 开始递归流程
        do {
            try {
                workLoop();
                break;
            }
            catch (e) {
                {
                    console.warn("workLoop Wrong", e);
                }
                workInProgress = null;
            }
        } while (temp);
        // root就是传入的FiberRootNode节点
        // root.current 是指向hostRootFiber节点
        // root.current.alternate 是我们在workLoop创建好的workInProgress指向的fiber树
        const finishedWork = root.current.alternate;
        root.finishedWork = finishedWork;
        commitRoot(root);
    }
    function commitRoot(root) {
        const finishedWork = root.finishedWork;
        if (finishedWork === null) {
            return;
        }
        {
            console.warn('commit阶段开始', finishedWork);
        }
        // 重置
        root.finishedWork = null;
        // 判断是否存在三个子阶段需要执行的操作
        // MutationMask就是Placement update等三个的合集， 下列语句用来判断子树副作用是否包含在mutation需要执行的这三个副作用
        const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
        const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
        if (subtreeHasEffect || rootHasEffect) {
            // 1. beforeMutation
            // 2. mutation(主要是Placement)
            commitMutationEffects(finishedWork);
            root.current = finishedWork;
            // 3. layout
        }
        else {
            // 不需要执行这些操作
            root.current = finishedWork;
        }
    }
    function workLoop() {
        while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
        }
    }
    function performUnitOfWork(fiber) {
        const next = beginWork(fiber);
        fiber.memoizedProps = fiber.pendingProps;
        if (next === null) {
            completeUnitOfWork(fiber);
        }
        else {
            workInProgress = next;
        }
    }
    // 遍历到底部了，判断该节点有没有兄弟节点
    function completeUnitOfWork(fiber) {
        let node = fiber;
        do {
            completeWork(node);
            const sibling = node.sibling;
            if (sibling !== null) {
                workInProgress = sibling;
                return;
            }
            // 如果没有兄弟节点，向上回溯（归）
            node = node.return;
            workInProgress = node;
        } while (node !== null);
    }

    // 在ReactDOMRoot.createRoot时，调用用于创建hostRootFiber和FiberRootNode
    function createContainer(container) {
        const hostRootFiber = new FiberNode(HostRoot, {}, null); // tag为HostRoot
        const root = new FiberRootNode(container, hostRootFiber);
        hostRootFiber.updateQueue = createUpdateQueue();
        return root;
    }
    // 将ReactElementType类型的<App/> 传入到 上一步创还能好的container中（root: FiberRootNode）
    function updateContainer(element, root) {
        // 第一次执行，调用render时就会第一次调用updateContainer
        const hostRootFiber = root.current;
        // 将element传入创建update的函数，表示此次更新与element相关的
        const update = createUpdate(element);
        enqueueUpdate(hostRootFiber.updateQueue, update);
        scheduleUpdateOnFiber(hostRootFiber);
        return element;
    }

    // ReactDOM.createRoot(root).render(<App/>)
    function createRoot(container) {
        // createContainer函数是不依赖宿主环境的
        // 创建FiberRootNode和hostRootFiber，并返回FiberRootNode
        const root = createContainer(container);
        return {
            render(element) {
                updateContainer(element, root);
            }
        };
    }

    var ReactDOM = /*#__PURE__*/Object.freeze({
        __proto__: null,
        createRoot: createRoot
    });

    return ReactDOM;

}));
